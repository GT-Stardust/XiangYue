const CharSets3={'0':'\u200C','1':'\u200D','2':'\u2060','3':'\u2061','4':'\u2062','5':'\u2063','6':'\u2064','7':'\u206A','8':'\u206B','9':'\u206C','a':'\u206D','b':'\u206E','c':'\u206F','d':'\u034F','e':'\uFEFF','f':'\u061C'};const ReverseCharSets3=Object.fromEntries(Object.entries(CharSets3).map(([k,v])=>[v,k]));const PAD_MARKER='\u200B';const ZERO_WIDTH_CHARS=new Set([...Object.values(CharSets3),PAD_MARKER]);const mappingMode3={base64ToZeroWidth(str){if(typeof str!=='string'){throw new TypeError('输入必须是字符串');}
const prefix=str[0]||'';const suffix=str[str.length-1]||'';const content=str.slice(1,-1);const bytes=new TextEncoder().encode(content);const hexStr=Array.from(bytes,b=>b.toString(16).padStart(2,'0')).join('');const padBits=(4-(hexStr.length*4%4))%4;const padMarker=CharSets3[(padBits/4).toString(16)];const fullHex=hexStr+'0'.repeat(padBits/4);let zeroWidthStr='';for(let i=0;i<fullHex.length;i++){zeroWidthStr+=CharSets3[fullHex[i]];}
return prefix+zeroWidthStr+padMarker+suffix;},zeroWidthToBase64(str){if(typeof str!=='string'){throw new TypeError('输入必须是字符串');}
const isZeroWidth=char=>ZERO_WIDTH_CHARS.has(char);let start=0;while(start<str.length&&!isZeroWidth(str[start]))start++;let end=str.length-1;while(end>=0&&!isZeroWidth(str[end]))end--;if(start>end)return str;const coreStr=str.slice(start,end+1);const padMarker=coreStr[coreStr.length-1]||'';const validPad=Math.min(Math.max(ReverseCharSets3[padMarker]?parseInt(ReverseCharSets3[padMarker],16)*4:0,0),3);const sequence=coreStr.slice(0,-1);const hexStr=sequence.split('').filter(ch=>ReverseCharSets3.hasOwnProperty(ch)).map(ch=>ReverseCharSets3[ch]).join('');const dataHex=hexStr.slice(0,hexStr.length-(validPad/4));const remaining=dataHex.length%2;const alignedHex=remaining?dataHex.slice(0,dataHex.length-remaining):dataHex;if(alignedHex.length===0){const prefix=start>0?str[start-1]:'';const suffix=end<str.length-1?str[end+1]:'';return prefix+suffix;}
try{const bytes=new Uint8Array(alignedHex.length/2);for(let i=0;i<bytes.length;i++){bytes[i]=parseInt(alignedHex.slice(i*2,(i+1)*2),16);}
const decodedContent=new TextDecoder().decode(bytes);const prefix=start>0?str[start-1]:'';const suffix=end<str.length-1?str[end+1]:'';return prefix+decodedContent+suffix;}catch(error){console.error('解码过程出错:',error);return str;}},async encodeBlob(blob){if(!(blob instanceof Blob)){throw new TypeError('输入必须是Blob对象');}
return new Promise((resolve,reject)=>{const reader=new FileReader();reader.onload=e=>{try{const base64Str=e.target.result.split(',')[1]||'';resolve(this.base64ToZeroWidth(base64Str));}catch(error){reject(error);}};reader.onerror=()=>reject(reader.error);reader.readAsDataURL(blob);});},decodeToBlob(str,mimeType='text/plain'){try{const decodedBase64=this.zeroWidthToBase64(str);const byteArray=new Uint8Array(atob(decodedBase64).split('').map(c=>c.charCodeAt(0)));return new Blob([byteArray],{type:mimeType});}catch(error){console.error('Blob解码出错:',error);return new Blob([`零宽字符解密失败: ${error.message}`],{type:'text/plain'});}}};